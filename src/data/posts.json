[
  {
    "id": 1,
    "tipo": "projeto",
    "categoria": "IoT & Automa√ß√£o",
    "titulo": "Sistema de Fumiga√ß√£o Inteligente",
    "data": "07 Fev 2026",
    "resumo": "Sistema completo para controle de pragas em silos com c√°lculos autom√°ticos.",
    "conteudo": "<p>Este projeto foi desenvolvido para otimizar o trabalho de fumiga√ß√£o em silos agr√≠colas. Utilizando HTML, CSS e JavaScript, criei uma ferramenta que calcula automaticamente a dosagem de pastilhas e sach√™s baseada no volume do silo.</p><p>O sistema tamb√©m conta com um m√≥dulo de hist√≥rico local para registrar as aplica√ß√µes realizadas.</p>",
    "imagem": "src/frontend/imagens/fumigacao/img2.jpeg",
    "github": "https://github.com/MoacirJr10/MyProject",
    "demo": "src/frontend/projeto.html"
  },
  {
    "id": 2,
    "tipo": "noticia",
    "categoria": "Servidores & IoT",
    "titulo": "Monitor de Servidor com ESP32-S3 (V1 e V2 com IA)",
    "data": "14 Fev 2026",
    "resumo": "Tutorial completo: Do monitoramento b√°sico ao avan√ßado com IA Gemini.",
    "conteudo": "<h3>üì∏ Galeria do Projeto</h3><p>Veja como o sistema evoluiu. Abaixo, as telas de monitoramento de CPU, RAM, Disco e Rel√≥gio:</p><div style='display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:20px;'><img src='src/frontend/imagens/esp32S3/esp32s3.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/esp32S3/esp32s32.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/esp32S3/esp32s33.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/esp32S3/esp32s34.jpeg' style='width:100%; border-radius:8px;'></div><hr><h2>Op√ß√£o 1: Vers√£o Cl√°ssica (Sem IA)</h2><p>Esta vers√£o √© ideal para quem quer apenas monitorar o hardware (CPU, RAM, Disco) de forma r√°pida e leve.</p><h3>üêç Backend Python (V1 - Simples)</h3><pre><code class='language-python'>import psutil\nimport time\nfrom flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route('/stats')\ndef get_stats():\n    cpu_cores = psutil.cpu_percent(interval=1, percpu=True) \n    ram = psutil.virtual_memory()\n    disk = psutil.disk_usage('/')\n    temp = 0\n    try:\n        t = psutil.sensors_temperatures()\n        if 'coretemp' in t: temp = int(t['coretemp'][0].current)\n    except: pass\n\n    return jsonify({\n        \"hostname\": \"UBUNTU-SERVER\",\n        \"cpu_cores\": cpu_cores,\n        \"temp\": temp,\n        \"ram_pct\": int(ram.percent),\n        \"ram_used\": round(ram.used / (1024**3), 2),\n        \"ram_total\": round(ram.total / (1024**3), 2),\n        \"disk_pct\": int(disk.percent),\n        \"disk_used\": round(disk.used / (1024**3), 1),\n        \"disk_total\": round(disk.total / (1024**3), 1)\n    })\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)</code></pre><h3>üíª Firmware ESP32 (V1 - 4 Telas)</h3><p>Este c√≥digo exibe 4 telas: CPU, RAM, Disco e Rel√≥gio. N√£o tem a tela da IA.</p><pre><code class='language-cpp'>#define LGFX_USE_V1\n#include <LovyanGFX.hpp>\n#include <WiFi.h>\n#include <HTTPClient.h>\n#include <ArduinoJson.h>\n#include \"time.h\"\n\n#define BUTTON_BOOT 0\n#define LCD_BL 48 \n\nclass LGFX_UICPAL : public lgfx::LGFX_Device {\n  lgfx::Panel_ILI9341 _panel_instance;\n  lgfx::Bus_SPI _bus_instance;\npublic:\n  LGFX_UICPAL(void) {\n    { auto cfg = _bus_instance.config(); cfg.spi_host = SPI2_HOST; cfg.pin_sclk = 3; cfg.pin_mosi = 45; cfg.pin_miso = 46; cfg.pin_dc = 47; cfg.freq_write = 40000000; _bus_instance.config(cfg); _panel_instance.setBus(&_bus_instance); }\n    { auto cfg = _panel_instance.config(); cfg.pin_cs = 14; cfg.pin_rst = 21; cfg.panel_width = 240; cfg.panel_height = 320; _panel_instance.config(cfg); }\n    setPanel(&_panel_instance);\n  }\n};\n\nLGFX_UICPAL lcd;\nLGFX_Sprite canvas(&lcd);\n\nconst char* ssid = \"SEU_WIFI\";\nconst char* password = \"SUA_SENHA\";\nconst char* serverUrl = \"http://192.168.X.X:5000/stats\";\n\nconst char* ntpServer = \"a.st1.ntp.br\";\nconst long  gmtOffset_sec = -10800;\nconst int   daylightOffset_sec = 0;\n\nint currentScreen = 0;\nconst int totalScreens = 4;\n\nint core_loads[12], num_cores = 0;\nint g_ram_pct, g_disk_pct, g_temp;\nfloat r_used, r_total, d_used, d_total;\nString g_host;\n\nvoid fetchData() {\n    if (WiFi.status() == WL_CONNECTED) {\n        HTTPClient http;\n        http.begin(serverUrl);\n        http.setTimeout(4000);\n        if (http.GET() == 200) {\n            DynamicJsonDocument doc(4096);\n            deserializeJson(doc, http.getString());\n            g_host = doc[\"hostname\"] | \"SERVER\";\n            g_temp = doc[\"temp\"] | 0;\n            JsonArray cores = doc[\"cpu_cores\"];\n            num_cores = cores.size();\n            for(int i=0; i < num_cores && i < 12; i++) core_loads[i] = cores[i];\n            g_ram_pct = doc[\"ram_pct\"] | 0;\n            r_used = doc[\"ram_used\"] | 0.0; r_total = doc[\"ram_total\"] | 0.0;\n            g_disk_pct = doc[\"disk_pct\"] | 0;\n            d_used = doc[\"disk_used\"] | 0.0; d_total = doc[\"disk_total\"] | 0.0;\n        }\n        http.end();\n    }\n}\n\nvoid drawUI() {\n    canvas.fillScreen(TFT_BLACK);\n    canvas.setTextColor(TFT_CYAN); canvas.setTextSize(2);\n    canvas.setCursor(10, 10); canvas.print(g_host);\n    canvas.setTextColor(g_temp > 65 ? TFT_RED : TFT_GREEN);\n    canvas.setCursor(240, 10); canvas.printf(\"%dC\", g_temp);\n    canvas.drawFastHLine(0, 35, 320, TFT_WHITE);\n\n    if (currentScreen == 0) { // CPU\n        canvas.drawCenterString(\"-- CORES CPU --\", 160, 45);\n        for(int i=0; i<num_cores; i++) {\n            int yPos = 70 + (i * 18);\n            canvas.drawRect(35, yPos, 230, 12, TFT_DARKGREY);\n            canvas.fillRect(37, yPos+2, map(core_loads[i],0,100,0,226), 8, (core_loads[i] > 80 ? TFT_RED : TFT_GREEN));\n        }\n    } else if (currentScreen == 1) { // RAM\n        canvas.drawCenterString(\"-- RAM --\", 160, 50);\n        canvas.setCursor(20, 100); canvas.printf(\"Uso: %d%%\", g_ram_pct);\n    } else if (currentScreen == 2) { // DISCO\n        canvas.drawCenterString(\"-- DISCO --\", 160, 50);\n        canvas.setCursor(20, 100); canvas.printf(\"Uso: %d%%\", g_disk_pct);\n    } else if (currentScreen == 3) { // REL√ìGIO\n        struct tm timeinfo;\n        if(getLocalTime(&timeinfo)){\n            char timeHour[9];\n            strftime(timeHour, 9, \"%H:%M:%S\", &timeinfo);\n            canvas.drawCenterString(timeHour, 160, 100);\n        }\n    }\n    canvas.pushSprite(0, 0);\n}\n\nvoid setup() {\n    pinMode(BUTTON_BOOT, INPUT_PULLUP);\n    pinMode(LCD_BL, OUTPUT); digitalWrite(LCD_BL, HIGH);\n    lcd.init(); lcd.setRotation(1);\n    canvas.createSprite(320, 240);\n    WiFi.begin(ssid, password);\n    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);\n    fetchData();\n}\n\nvoid loop() {\n    static unsigned long lastUpdate = 0;\n    if (millis() - lastUpdate > 3000) { fetchData(); lastUpdate = millis(); }\n    if (digitalRead(BUTTON_BOOT) == LOW) {\n        currentScreen = (currentScreen + 1) % totalScreens;\n        delay(250);\n    }\n    drawUI();\n}</code></pre><hr><h2>Op√ß√£o 2: Vers√£o Avan√ßada (Com IA Gemini)</h2><p>Esta vers√£o adiciona uma camada de intelig√™ncia artificial que analisa os dados e gera um resumo em linguagem natural.</p><h3>üîê Passo a Passo: Configurando a IA com Seguran√ßa</h3><p>Para usar o Gemini, voc√™ precisa de uma chave de API (API Key). Siga estes passos para configurar com seguran√ßa:</p><ol><li>Acesse o <a href='https://aistudio.google.com/' target='_blank'>Google AI Studio</a> e crie uma chave gratuita.</li><li>No seu servidor Ubuntu, instale a biblioteca oficial: <code>pip install google-genai</code>.</li><li><strong>Seguran√ßa Cr√≠tica:</strong> Nunca cole sua chave diretamente no c√≥digo se for compartilhar o arquivo. Use vari√°veis de ambiente ou um arquivo <code>.env</code>.</li></ol><h3>üêç Backend Python (V2 - Com IA)</h3><pre><code class='language-python'>import psutil\nimport time\nimport os\nfrom google import genai\nfrom flask import Flask, jsonify\n\napp = Flask(__name__)\n\n# --- CONFIGURA√á√ÉO SEGURA ---\n# A chave √© lida das vari√°veis de ambiente do sistema\nCHAVE_API = os.getenv(\"GEMINI_API_KEY\") \n\nif not CHAVE_API:\n    print(\"ERRO: Chave GEMINI_API_KEY n√£o encontrada!\")\n    # Em produ√ß√£o, voc√™ pode usar um valor fixo APENAS se o c√≥digo n√£o for p√∫blico\n    # CHAVE_API = \"SUA_CHAVE_AQUI\"\n\nclient = genai.Client(api_key=CHAVE_API)\nMODELO_ATUAL = \"gemini-2.0-flash\" \n\n# Sistema de Cache para evitar Erro 429\nlast_ai_response = \"Sincronizando com Gemini...\"\nlast_ai_time = 0\nAI_COOLDOWN = 120  # 2 minutos\n\n@app.route('/stats')\ndef get_stats():\n    global last_ai_response, last_ai_time\n    # ... (C√≥digo de coleta de hardware igual ao V1) ...\n    \n    # L√≥gica de IA\n    current_time = time.time()\n    if (current_time - last_ai_time) > AI_COOLDOWN:\n        # ... (Chamada ao Gemini) ...\n        pass\n\n    return jsonify({\n        # ... (Dados de hardware) ...\n        \"gemini_info\": last_ai_response\n    })\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)</code></pre><h3>üíª Firmware ESP32 (V2 - 5 Telas com IA)</h3><p>Este c√≥digo adiciona a 5¬™ tela para exibir o texto gerado pelo Gemini.</p><pre><code class='language-cpp'>#define LGFX_USE_V1\n#include <LovyanGFX.hpp>\n#include <WiFi.h>\n#include <HTTPClient.h>\n#include <ArduinoJson.h>\n#include \"time.h\"\n\n// ... (Configura√ß√£o do LCD igual √† V1) ...\n\nconst int totalScreens = 5; // AGORA S√ÉO 5 TELAS\nString g_gemini = \"Aguardando IA...\";\n\nvoid fetchData() {\n    // ... (Conex√£o HTTP igual √† V1) ...\n    if (http.GET() == 200) {\n        // ... (Deserializa√ß√£o igual √† V1) ...\n        g_gemini = doc[\"gemini_info\"] | \"Processando...\"; // L√ä O CAMPO NOVO\n    }\n}\n\nvoid drawUI() {\n    // ... (Desenho do Header igual √† V1) ...\n\n    if (currentScreen == 4) { // --- NOVA TELA: GEMINI AI ---\n        canvas.setTextColor(TFT_MAGENTA);\n        canvas.drawCenterString(\"-- GEMINI AI 2.0 --\", 160, 45);\n        canvas.setTextColor(TFT_WHITE); canvas.setTextSize(2);\n        canvas.setCursor(10, 100);\n        canvas.println(g_gemini);\n    } \n    // ... (Outras telas 0 a 3 iguais √† V1) ...\n    \n    canvas.pushSprite(0, 0);\n}\n\n// ... (Setup e Loop iguais √† V1) ...</code></pre><h3>üõ†Ô∏è Manuten√ß√£o do Servidor</h3><p>Para garantir que seu monitoramento rode 24/7, use estes comandos:</p><pre><code># Ver se o servi√ßo est√° rodando\nsudo systemctl status esp32_stats.service\n\n# Reiniciar ap√≥s mudar o c√≥digo\nsudo systemctl restart esp32_stats.service\n\n# Ver logs de erro em tempo real\njournalctl -u esp32_stats.service -f</code></pre>",
    "imagem": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?q=80&w=1000&auto=format&fit=crop",
    "github": ""
  },
  {
    "id": 3,
    "tipo": "projeto",
    "categoria": "Java Desktop",
    "titulo": "Or√ßamento de M√≥veis Planejados",
    "data": "20 Jan 2026",
    "resumo": "Aplica√ß√£o em Java para gera√ß√£o de or√ßamentos r√°pidos para marcenaria.",
    "conteudo": "<p>Aplica√ß√£o Desktop desenvolvida em Java para auxiliar marceneiros. O sistema permite cadastrar materiais, calcular custos de produ√ß√£o e gerar um pre√ßo final de venda com margem de lucro configur√°vel.</p>",
    "imagem": "src/frontend/imagens/java/orcamento-moveis.jpeg",
    "github": "https://github.com/MoacirJr10/OrcamentoMoveisPlanejados"
  },
  {
    "id": 4,
    "tipo": "projeto",
    "categoria": "Hardware / IoT",
    "titulo": "Monitoramento com ESP32 e OLED",
    "data": "15 Dez 2025",
    "resumo": "Integra√ß√£o de sensores e displays para visualiza√ß√£o de dados em tempo real.",
    "conteudo": "<p>Projeto focado em IoT utilizando o microcontrolador ESP32. O objetivo foi criar uma interface visual em um display OLED de 0.96 polegadas para exibir dados coletados de sensores em tempo real.</p>",
    "imagem": "src/frontend/imagens/arduino/esp32-oled.jpeg",
    "github": "https://github.com/MoacirJr10/ESP32-oled-test"
  },
  {
    "id": 5,
    "tipo": "projeto",
    "categoria": "Arduino",
    "titulo": "Sensores com Arduino",
    "data": "10 Nov 2025",
    "resumo": "Coleta de dados ambientais utilizando sensores diversos.",
    "conteudo": "<p>Experimentos pr√°ticos de eletr√¥nica para leitura de temperatura, umidade e luminosidade, processando os dados atrav√©s de um Arduino Uno.</p>",
    "imagem": "src/frontend/imagens/arduino/sensor1.jpeg",
    "github": "https://github.com/MoacirJr10/arduino_sensor"
  },
  {
    "id": 6,
    "tipo": "projeto",
    "categoria": "Displays",
    "titulo": "Display LCD com Arduino",
    "data": "05 Out 2025",
    "resumo": "Interface homem-m√°quina utilizando displays de cristal l√≠quido.",
    "conteudo": "<p>Implementa√ß√£o de menus e exibi√ß√£o de informa√ß√µes em displays LCD 16x2, criando uma interface amig√°vel para projetos de automa√ß√£o.</p>",
    "imagem": "src/frontend/imagens/arduino/lcd1.jpeg",
    "github": "https://github.com/MoacirJr10/lcd-arduino"
  },
  {
    "id": 7,
    "tipo": "projeto",
    "categoria": "Automa√ß√£o Windows",
    "titulo": "SysBot - Automa√ß√£o e Manuten√ß√£o",
    "data": "08 Fev 2026",
    "resumo": "Ferramenta completa para manuten√ß√£o, limpeza e diagn√≥stico do Windows via script.",
    "conteudo": "<h3>üöÄ O que √© o SysBot?</h3><p>O SysBot √© uma ferramenta poderosa organizada em m√≥dulos para facilitar a vida de t√©cnicos e usu√°rios avan√ßados. Ele automatiza tarefas repetitivas e diagn√≥sticos complexos.</p><h4>Principais M√≥dulos:</h4><ul><li><strong>Manuten√ß√£o:</strong> Windows Update, SFC e DISM.</li><li><strong>Hardware:</strong> Resumo detalhado de CPU, GPU e RAM.</li><li><strong>Rede:</strong> Testes de conectividade e velocidade.</li><li><strong>Limpeza:</strong> Remo√ß√£o segura de arquivos tempor√°rios e cache.</li><li><strong>Otimiza√ß√£o:</strong> Desfragmenta√ß√£o e ajustes de energia.</li></ul><h3>üì∏ Galeria do Projeto</h3><div style='display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px; margin-bottom:20px;'><img src='src/frontend/imagens/sysbot/sysbot2.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/sysbot/sysbot3.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/sysbot/sysbot4.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/sysbot/sysbot5.jpeg' style='width:100%; border-radius:8px;'></div><h3>üíª Como Usar</h3><ol><li>Baixe os arquivos do reposit√≥rio.</li><li>Clique com o bot√£o direito em <code>run_admin.bat</code>.</li><li>Selecione 'Executar como administrador'.</li></ol><p>Compat√≠vel com Windows 10 e 11 (total) e Windows 7/8.1 (parcial).</p>",
    "imagem": "src/frontend/imagens/sysbot/sysbot1.jpeg",
    "github": "https://github.com/MoacirJr10/SysBot"
  }
]
