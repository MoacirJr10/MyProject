[
  {
    "id": 1,
    "tipo": "projeto",
    "categoria": "IoT & Automa√ß√£o",
    "titulo": "Sistema de Fumiga√ß√£o Inteligente",
    "data": "07 Fev 2026",
    "resumo": "Sistema completo para controle de pragas em silos com c√°lculos autom√°ticos.",
    "conteudo": "<p>Este projeto foi desenvolvido para otimizar o trabalho de fumiga√ß√£o em silos agr√≠colas. Utilizando HTML, CSS e JavaScript, criei uma ferramenta que calcula automaticamente a dosagem de pastilhas e sach√™s baseada no volume do silo.</p><p>O sistema tamb√©m conta com um m√≥dulo de hist√≥rico local para registrar as aplica√ß√µes realizadas.</p>",
    "imagem": "src/frontend/imagens/fumigacao/img2.jpeg",
    "github": "https://github.com/MoacirJr10/MyProject",
    "demo": "src/frontend/projeto.html"
  },
  {
    "id": 2,
    "tipo": "noticia",
    "categoria": "Servidores & IoT",
    "titulo": "Monitor de Servidor com ESP32-S3",
    "data": "14 Fev 2026",
    "resumo": "Tutorial completo: Do Ubuntu Server b√°sico ao monitoramento f√≠sico com ESP32.",
    "conteudo": "<h3>üì∏ Galeria do Projeto</h3><p>Veja o sistema em a√ß√£o. Abaixo, as telas de monitoramento de CPU, RAM, Disco e Rel√≥gio:</p><div style='display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:20px;'><img src='src/frontend/imagens/esp32S3/esp32s3.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/esp32S3/esp32s32.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/esp32S3/esp32s33.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/esp32S3/esp32s34.jpeg' style='width:100%; border-radius:8px;'></div><hr><h3>üêß Parte 1: Configura√ß√£o do Ubuntu Server</h3><p>Antes de rodar o c√≥digo, precisamos preparar o ambiente. Abra o terminal do seu servidor e siga os passos:</p><h4>1. Atualizar e Instalar Depend√™ncias</h4><p>Primeiro, garantimos que o sistema est√° seguro e instalamos o Python e ferramentas de rede.</p><pre><code>sudo apt update && sudo apt upgrade -y\nsudo apt install net-tools python3-pip python3-venv -y</code></pre><h4>2. Configurar o Firewall (UFW)</h4><p>Para que o ESP32 consiga conversar com o servidor, precisamos abrir a porta 5000.</p><pre><code>sudo ufw allow 22/tcp   # Mant√©m o SSH aberto (Importante!)\nsudo ufw allow 5000/tcp # Abre a porta da nossa API\nsudo ufw enable         # Ativa o firewall</code></pre><h4>3. Criar o Ambiente Python</h4><p>Vamos criar uma pasta organizada para o projeto.</p><pre><code>mkdir ~/server_monitor\ncd ~/server_monitor\npython3 -m venv venv\nsource venv/bin/activate\npip install flask psutil</code></pre><hr><h3>üêç Parte 2: Backend Python (API de Status)</h3><p>Este script coleta os dados do PC e cria uma p√°gina web leve (JSON) que o ESP32 consegue ler. Salve como <code>stats_server.py</code>:</p><pre><code class='language-python'>import psutil\nimport time\nfrom flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route('/stats')\ndef get_stats():\n    cpu_cores = psutil.cpu_percent(interval=1, percpu=True) \n    ram = psutil.virtual_memory()\n    disk = psutil.disk_usage('/')\n    temp = 0\n    try:\n        t = psutil.sensors_temperatures()\n        if 'coretemp' in t: temp = int(t['coretemp'][0].current)\n    except: pass\n\n    return jsonify({\n        \"hostname\": \"UBUNTU-SERVER\",\n        \"cpu_cores\": cpu_cores,\n        \"temp\": temp,\n        \"ram_pct\": int(ram.percent),\n        \"ram_used\": round(ram.used / (1024**3), 2),\n        \"ram_total\": round(ram.total / (1024**3), 2),\n        \"disk_pct\": int(disk.percent),\n        \"disk_used\": round(disk.used / (1024**3), 1),\n        \"disk_total\": round(disk.total / (1024**3), 1)\n    })\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)</code></pre><h3>üíª Parte 3: Firmware ESP32 (4 Telas)</h3><p>Este √© o c√≥digo C++ completo. Ele usa a biblioteca LovyanGFX para desenhar as telas de CPU, RAM, Disco e Rel√≥gio.</p><pre><code class='language-cpp'>#define LGFX_USE_V1\n#include <LovyanGFX.hpp>\n#include <WiFi.h>\n#include <HTTPClient.h>\n#include <ArduinoJson.h>\n#include \"time.h\"\n\n#define BUTTON_BOOT 0\n#define LCD_BL 48 \n\nclass LGFX_UICPAL : public lgfx::LGFX_Device {\n  lgfx::Panel_ILI9341 _panel_instance;\n  lgfx::Bus_SPI _bus_instance;\npublic:\n  LGFX_UICPAL(void) {\n    { auto cfg = _bus_instance.config(); cfg.spi_host = SPI2_HOST; cfg.pin_sclk = 3; cfg.pin_mosi = 45; cfg.pin_miso = 46; cfg.pin_dc = 47; cfg.freq_write = 40000000; _bus_instance.config(cfg); _panel_instance.setBus(&_bus_instance); }\n    { auto cfg = _panel_instance.config(); cfg.pin_cs = 14; cfg.pin_rst = 21; cfg.panel_width = 240; cfg.panel_height = 320; _panel_instance.config(cfg); }\n    setPanel(&_panel_instance);\n  }\n};\n\nLGFX_UICPAL lcd;\nLGFX_Sprite canvas(&lcd);\n\nconst char* ssid = \"SEU_WIFI\";\nconst char* password = \"SUA_SENHA\";\nconst char* serverUrl = \"http://192.168.X.X:5000/stats\";\n\nconst char* ntpServer = \"a.st1.ntp.br\";\nconst long  gmtOffset_sec = -10800;\nconst int   daylightOffset_sec = 0;\n\nint currentScreen = 0;\nconst int totalScreens = 4;\n\nint core_loads[12], num_cores = 0;\nint g_ram_pct, g_disk_pct, g_temp;\nfloat r_used, r_total, d_used, d_total;\nString g_host;\n\nvoid fetchData() {\n    if (WiFi.status() == WL_CONNECTED) {\n        HTTPClient http;\n        http.begin(serverUrl);\n        http.setTimeout(4000);\n        if (http.GET() == 200) {\n            DynamicJsonDocument doc(4096);\n            deserializeJson(doc, http.getString());\n            g_host = doc[\"hostname\"] | \"SERVER\";\n            g_temp = doc[\"temp\"] | 0;\n            JsonArray cores = doc[\"cpu_cores\"];\n            num_cores = cores.size();\n            for(int i=0; i < num_cores && i < 12; i++) core_loads[i] = cores[i];\n            g_ram_pct = doc[\"ram_pct\"] | 0;\n            r_used = doc[\"ram_used\"] | 0.0; r_total = doc[\"ram_total\"] | 0.0;\n            g_disk_pct = doc[\"disk_pct\"] | 0;\n            d_used = doc[\"disk_used\"] | 0.0; d_total = doc[\"disk_total\"] | 0.0;\n        }\n        http.end();\n    }\n}\n\nvoid drawUI() {\n    canvas.fillScreen(TFT_BLACK);\n    canvas.setTextColor(TFT_CYAN); canvas.setTextSize(2);\n    canvas.setCursor(10, 10); canvas.print(g_host);\n    canvas.setTextColor(g_temp > 65 ? TFT_RED : TFT_GREEN);\n    canvas.setCursor(240, 10); canvas.printf(\"%dC\", g_temp);\n    canvas.drawFastHLine(0, 35, 320, TFT_WHITE);\n\n    if (currentScreen == 0) { // CPU\n        canvas.drawCenterString(\"-- CORES CPU --\", 160, 45);\n        for(int i=0; i<num_cores; i++) {\n            int yPos = 70 + (i * 18);\n            canvas.drawRect(35, yPos, 230, 12, TFT_DARKGREY);\n            canvas.fillRect(37, yPos+2, map(core_loads[i],0,100,0,226), 8, (core_loads[i] > 80 ? TFT_RED : TFT_GREEN));\n        }\n    } else if (currentScreen == 1) { // RAM\n        canvas.drawCenterString(\"-- RAM --\", 160, 50);\n        canvas.setCursor(20, 100); canvas.printf(\"Uso: %d%%\", g_ram_pct);\n    } else if (currentScreen == 2) { // DISCO\n        canvas.drawCenterString(\"-- DISCO --\", 160, 50);\n        canvas.setCursor(20, 100); canvas.printf(\"Uso: %d%%\", g_disk_pct);\n    } else if (currentScreen == 3) { // REL√ìGIO\n        struct tm timeinfo;\n        if(getLocalTime(&timeinfo)){\n            char timeHour[9];\n            strftime(timeHour, 9, \"%H:%M:%S\", &timeinfo);\n            canvas.drawCenterString(timeHour, 160, 100);\n        }\n    }\n    canvas.pushSprite(0, 0);\n}\n\nvoid setup() {\n    pinMode(BUTTON_BOOT, INPUT_PULLUP);\n    pinMode(LCD_BL, OUTPUT); digitalWrite(LCD_BL, HIGH);\n    lcd.init(); lcd.setRotation(1);\n    canvas.createSprite(320, 240);\n    WiFi.begin(ssid, password);\n    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);\n    fetchData();\n}\n\nvoid loop() {\n    static unsigned long lastUpdate = 0;\n    if (millis() - lastUpdate > 3000) { fetchData(); lastUpdate = millis(); }\n    if (digitalRead(BUTTON_BOOT) == LOW) {\n        currentScreen = (currentScreen + 1) % totalScreens;\n        delay(250);\n    }\n    drawUI();\n}</code></pre><h3>üõ†Ô∏è Manuten√ß√£o do Servidor</h3><p>Para garantir que seu monitoramento rode 24/7, use estes comandos:</p><pre><code># Ver se o servi√ßo est√° rodando\nsudo systemctl status esp32_stats.service\n\n# Reiniciar ap√≥s mudar o c√≥digo\nsudo systemctl restart esp32_stats.service\n\n# Ver logs de erro em tempo real\njournalctl -u esp32_stats.service -f</code></pre>",
    "imagem": "https://images.unsplash.com/photo-1629654297299-c8506221ca97?q=80&w=1000&auto=format&fit=crop",
    "github": ""
  },
  {
    "id": 3,
    "tipo": "projeto",
    "categoria": "Java Desktop",
    "titulo": "Or√ßamento de M√≥veis Planejados",
    "data": "20 Jan 2026",
    "resumo": "Aplica√ß√£o em Java para gera√ß√£o de or√ßamentos r√°pidos para marcenaria.",
    "conteudo": "<p>Aplica√ß√£o Desktop desenvolvida em Java para auxiliar marceneiros. O sistema permite cadastrar materiais, calcular custos de produ√ß√£o e gerar um pre√ßo final de venda com margem de lucro configur√°vel.</p>",
    "imagem": "src/frontend/imagens/java/orcamento-moveis.jpeg",
    "github": "https://github.com/MoacirJr10/OrcamentoMoveisPlanejados"
  },
  {
    "id": 4,
    "tipo": "projeto",
    "categoria": "Hardware / IoT",
    "titulo": "Monitoramento com ESP32 e OLED",
    "data": "15 Dez 2025",
    "resumo": "Integra√ß√£o de sensores e displays para visualiza√ß√£o de dados em tempo real.",
    "conteudo": "<p>Projeto focado em IoT utilizando o microcontrolador ESP32. O objetivo foi criar uma interface visual em um display OLED de 0.96 polegadas para exibir dados coletados de sensores em tempo real.</p>",
    "imagem": "src/frontend/imagens/arduino/esp32-oled.jpeg",
    "github": "https://github.com/MoacirJr10/ESP32-oled-test"
  },
  {
    "id": 5,
    "tipo": "projeto",
    "categoria": "Arduino",
    "titulo": "Sensores com Arduino",
    "data": "10 Nov 2025",
    "resumo": "Coleta de dados ambientais utilizando sensores diversos.",
    "conteudo": "<p>Experimentos pr√°ticos de eletr√¥nica para leitura de temperatura, umidade e luminosidade, processando os dados atrav√©s de um Arduino Uno.</p>",
    "imagem": "src/frontend/imagens/arduino/sensor1.jpeg",
    "github": "https://github.com/MoacirJr10/arduino_sensor"
  },
  {
    "id": 6,
    "tipo": "projeto",
    "categoria": "Displays",
    "titulo": "Display LCD com Arduino",
    "data": "05 Out 2025",
    "resumo": "Interface homem-m√°quina utilizando displays de cristal l√≠quido.",
    "conteudo": "<p>Implementa√ß√£o de menus e exibi√ß√£o de informa√ß√µes em displays LCD 16x2, criando uma interface amig√°vel para projetos de automa√ß√£o.</p>",
    "imagem": "src/frontend/imagens/arduino/lcd1.jpeg",
    "github": "https://github.com/MoacirJr10/lcd-arduino"
  },
  {
    "id": 7,
    "tipo": "projeto",
    "categoria": "Automa√ß√£o Windows",
    "titulo": "SysBot - Automa√ß√£o e Manuten√ß√£o",
    "data": "08 Fev 2026",
    "resumo": "Ferramenta completa para manuten√ß√£o, limpeza e diagn√≥stico do Windows via script.",
    "conteudo": "<h3>üöÄ O que √© o SysBot?</h3><p>O SysBot √© uma ferramenta poderosa organizada em m√≥dulos para facilitar a vida de t√©cnicos e usu√°rios avan√ßados. Ele automatiza tarefas repetitivas e diagn√≥sticos complexos.</p><h4>Principais M√≥dulos:</h4><ul><li><strong>Manuten√ß√£o:</strong> Windows Update, SFC e DISM.</li><li><strong>Hardware:</strong> Resumo detalhado de CPU, GPU e RAM.</li><li><strong>Rede:</strong> Testes de conectividade e velocidade.</li><li><strong>Limpeza:</strong> Remo√ß√£o segura de arquivos tempor√°rios e cache.</li><li><strong>Otimiza√ß√£o:</strong> Desfragmenta√ß√£o e ajustes de energia.</li></ul><h3>üì∏ Galeria do Projeto</h3><div style='display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px; margin-bottom:20px;'><img src='src/frontend/imagens/sysbot/sysbot2.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/sysbot/sysbot3.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/sysbot/sysbot4.jpeg' style='width:100%; border-radius:8px;'><img src='src/frontend/imagens/sysbot/sysbot5.jpeg' style='width:100%; border-radius:8px;'></div><h3>üíª Como Usar</h3><ol><li>Baixe os arquivos do reposit√≥rio.</li><li>Clique com o bot√£o direito em <code>run_admin.bat</code>.</li><li>Selecione 'Executar como administrador'.</li></ol><p>Compat√≠vel com Windows 10 e 11 (total) e Windows 7/8.1 (parcial).</p>",
    "imagem": "src/frontend/imagens/sysbot/sysbot1.jpeg",
    "github": "https://github.com/MoacirJr10/SysBot"
  }
]
